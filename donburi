#!/bin/bash

# Donburi CLI
# A unified macOS dotfiles configuration tool
#
# Usage: donburi <command> [options]
#
# Commands:
#   setup [component]     Install configurations
#   status                Show symlink status
#   brew [category]       Install packages via Homebrew
#   update                Update donburi (git pull)
#   help                  Show this help message

set -e

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------
# Resolve symlinks to find the actual script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    # Handle relative symlinks
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
DONBURI_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
BACKUP_DIR="$HOME/.config/donburi-backup-$(date +%Y%m%d-%H%M%S)"

# Source paths
SRC_NVIM="$DONBURI_DIR/nvim"
SRC_GHOSTTY="$DONBURI_DIR/ghostty/config"
SRC_AEROSPACE="$DONBURI_DIR/aerospace"
SRC_TMUX="$DONBURI_DIR/tmux/tmux.conf"
SRC_ZSH="$DONBURI_DIR/zsh/zshrc"
SRC_ZSH_DONBURI="$DONBURI_DIR/zsh/donburi.zsh"
SRC_SKETCHYBAR="$DONBURI_DIR/sketchybar"

# Target paths
DST_NVIM="$HOME/.config/nvim"
DST_GHOSTTY="$HOME/Library/Application Support/com.mitchellh.ghostty/config"
DST_AEROSPACE="$HOME/.config/aerospace"
DST_TMUX="$HOME/.tmux.conf"
DST_ZSH="$HOME/.zshrc"
DST_ZSH_DONBURI="$HOME/.donburi.zsh"
DST_SKETCHYBAR="$HOME/.config/sketchybar"

# ---------------------------------------------------------------------------
# Options
# ---------------------------------------------------------------------------
DRY_RUN=false
LIST_ONLY=false
NO_BREW=false

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# ---------------------------------------------------------------------------
# Brew Detection
# ---------------------------------------------------------------------------
BREW_CMD=""
BREW_PREFIX=""

# Common brew installation locations
BREW_LOCATIONS=(
    "/opt/homebrew/bin/brew"          # Apple Silicon Macs
    "/usr/local/bin/brew"              # Intel Macs
    "/home/linuxbrew/.linuxbrew/bin/brew"  # Linux
    "$HOME/.brew/bin/brew"             # User installation
    "$HOME/.local/homebrew/bin/brew"   # Alternative user installation
)

# Find brew command - checks custom path first, then common locations
find_brew() {
    # Check if already found
    [[ -n "$BREW_CMD" ]] && return 0

    # Check custom path from environment
    if [[ -n "${DONBURI_BREW_PATH:-}" ]] && [[ -x "${DONBURI_BREW_PATH}" ]]; then
        BREW_CMD="${DONBURI_BREW_PATH}"
        BREW_PREFIX="$(dirname "$(dirname "$BREW_CMD")")"
        return 0
    fi

    # Check if brew is in PATH
    if command -v brew &>/dev/null; then
        BREW_CMD="$(command -v brew)"
        BREW_PREFIX="$(brew --prefix 2>/dev/null || dirname "$(dirname "$BREW_CMD")")"
        return 0
    fi

    # Check common locations
    for location in "${BREW_LOCATIONS[@]}"; do
        if [[ -x "$location" ]]; then
            BREW_CMD="$location"
            BREW_PREFIX="$(dirname "$(dirname "$BREW_CMD")")"
            return 0
        fi
    done

    # Not found
    return 1
}

# Check if running with sudo
is_sudo() {
    [[ -n "${SUDO_USER:-}" ]] || [[ "$EUID" -eq 0 ]]
}

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------
log_info()  { echo -e "${GREEN}[INFO]${NC}  $1"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC}  $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

# Check if a symlink already points to the correct source
is_correct_symlink() {
    local target="$1"
    local source="$2"
    [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$source" ]]
}

# Backup a file, directory, or dangling symlink before replacing it.
# Skips if target doesn't exist at all.
backup_if_exists() {
    local target="$1"

    # Nothing to back up
    [[ ! -e "$target" && ! -L "$target" ]] && return 0

    mkdir -p "$BACKUP_DIR"

    # Deduplicate backup names when the same basename appears twice
    local base
    base="$(basename "$target")"
    local backup_path="$BACKUP_DIR/$base"
    local n=1
    while [[ -e "$backup_path" ]]; do
        backup_path="$BACKUP_DIR/${base}.$n"
        ((n++))
    done

    if [[ "$DRY_RUN" == true ]]; then
        if [[ -L "$target" ]]; then
            log_warn "Would remove symlink: $target (-> $(readlink "$target"))"
        else
            log_warn "Would backup: $target -> $backup_path"
        fi
    else
        if [[ -L "$target" ]]; then
            local old_dest
            old_dest="$(readlink "$target")"
            rm "$target"
            log_info "Removed old symlink: $target (-> $old_dest)"
        else
            mv "$target" "$backup_path"
            log_info "Backed up: $target -> $backup_path"
        fi
    fi
}

# Create a symlink from $1 (source) to $2 (target).
# Handles existing symlinks, regular files, and directories.
create_symlink() {
    local source="$1"
    local target="$2"

    if [[ ! -e "$source" ]]; then
        log_error "Source does not exist: $source"
        return 1
    fi

    # Already correct — nothing to do
    if is_correct_symlink "$target" "$source"; then
        log_info "Already linked: $target"
        return 0
    fi

    # Ensure parent directory exists
    local target_dir
    target_dir="$(dirname "$target")"
    if [[ ! -d "$target_dir" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "Would create directory: $target_dir"
        else
            mkdir -p "$target_dir"
            log_info "Created directory: $target_dir"
        fi
    fi

    # Backup whatever is currently at the target path
    backup_if_exists "$target"

    # Create the symlink
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would symlink: $target -> $source"
    else
        ln -s "$source" "$target"
        log_info "Symlinked: $target -> $source"
    fi
}

# Install or upgrade a Homebrew formula
brew_install() {
    local name="$1"
    local type="${2:-formula}" # "formula" or "cask"

    # Skip if NO_BREW is set
    if [[ "$NO_BREW" == true ]]; then
        log_warn "Skipping brew package: $name (--no-brew mode)"
        return 0
    fi

    # Ensure brew is found
    if ! find_brew; then
        log_warn "Homebrew not found, skipping: $name"
        return 1
    fi

    if [[ "$DRY_RUN" == true ]]; then
        if "$BREW_CMD" list --"${type}" "$name" &>/dev/null; then
            log_info "Would upgrade $type: $name"
        else
            log_info "Would install $type: $name"
        fi
        return 0
    fi

    if "$BREW_CMD" list --"${type}" "$name" &>/dev/null; then
        log_info "Upgrading $type: $name"
        "$BREW_CMD" upgrade --"${type}" "$name" 2>/dev/null || log_info "Already up to date: $name"
    else
        log_info "Installing $type: $name"
        "$BREW_CMD" install ${type:+--${type}} "$name"
    fi
}

# Make scripts executable inside a directory
make_executable() {
    local dir="$1"
    local pattern="$2"
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would chmod +x: $dir/$pattern"
    else
        chmod +x "$dir"/"$pattern" 2>/dev/null || true
    fi
}

# ---------------------------------------------------------------------------
# Brew Package Categories
# ---------------------------------------------------------------------------

# Apps: UI applications managed by donburi
BREW_APPS_FORMULA=(neovim tmux sketchybar jq FelixKratz/formulae/borders)
BREW_APPS_CASK=(ghostty nikitabobko/tap/aerospace)

# CLI: Essential command-line tools
BREW_CLI_FORMULA=(bat lsd fzf ripgrep htop wget bash gcc make gnu-sed gawk curl)

# Utils: Development utilities and communication apps
BREW_UTILS_FORMULA=(node python)
BREW_UTILS_CASK=(slack discord spotify)

# Docker: Container development tools
BREW_DOCKER_FORMULA=(colima docker docker-compose docker-buildx)

# ---------------------------------------------------------------------------
# Setup Commands
# ---------------------------------------------------------------------------

setup_nvim() {
    echo -e "${CYAN}--- nvim ---${NC}"

    # Nvim dependencies via Homebrew
    if [[ "$NO_BREW" != true ]] && find_brew; then
        local nvim_deps=(ripgrep gcc make)
        for pkg in "${nvim_deps[@]}"; do
            if ! "$BREW_CMD" list --formula "$pkg" &>/dev/null; then
                if [[ "$DRY_RUN" == true ]]; then
                    log_info "Would install formula: $pkg"
                else
                    log_info "Installing formula: $pkg"
                    "$BREW_CMD" install "$pkg"
                fi
            else
                log_info "Already installed: $pkg"
            fi
        done
    elif [[ "$NO_BREW" == true ]]; then
        log_info "Skipping brew dependencies (--no-brew mode)"
    else
        log_warn "Homebrew not found — skipping nvim dependencies"
    fi

    # Install lazy.nvim plugin manager if missing
    local lazypath="${XDG_DATA_HOME:-$HOME/.local/share}/nvim/lazy/lazy.nvim"
    if [[ ! -d "$lazypath" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "Would install lazy.nvim plugin manager"
        else
            log_info "Installing lazy.nvim plugin manager..."
            git clone --filter=blob:none --branch=stable https://github.com/folke/lazy.nvim.git "$lazypath"
        fi
    else
        log_info "lazy.nvim already installed"
    fi

    create_symlink "$SRC_NVIM" "$DST_NVIM"
    log_info "Plugins and LSPs will auto-install on first nvim launch (mason)"
}

setup_ghostty() {
    echo -e "${CYAN}--- ghostty ---${NC}"

    # Install JetBrains Mono Nerd Font
    if [[ "$NO_BREW" != true ]] && find_brew; then
        if ! "$BREW_CMD" list --cask font-jetbrains-mono-nerd-font &>/dev/null; then
            if [[ "$DRY_RUN" == true ]]; then
                log_info "Would install cask: font-jetbrains-mono-nerd-font"
            else
                log_info "Installing cask: font-jetbrains-mono-nerd-font"
                "$BREW_CMD" install --cask font-jetbrains-mono-nerd-font
            fi
        else
            log_info "Already installed: font-jetbrains-mono-nerd-font"
        fi
    elif [[ "$NO_BREW" == true ]]; then
        log_info "Skipping font installation (--no-brew mode)"
    else
        log_warn "Homebrew not found — skipping font installation"
    fi

    create_symlink "$SRC_GHOSTTY" "$DST_GHOSTTY"
}

setup_aerospace() {
    echo -e "${CYAN}--- aerospace ---${NC}"

    # Aerospace dependencies via Homebrew
    if [[ "$NO_BREW" != true ]] && find_brew; then
        local aero_deps=(jq bash FelixKratz/formulae/borders)
        for pkg in "${aero_deps[@]}"; do
            if ! "$BREW_CMD" list --formula "$pkg" &>/dev/null; then
                if [[ "$DRY_RUN" == true ]]; then
                    log_info "Would install formula: $pkg"
                else
                    log_info "Installing formula: $pkg"
                    "$BREW_CMD" install "$pkg"
                fi
            else
                log_info "Already installed: $pkg"
            fi
        done
    elif [[ "$NO_BREW" == true ]]; then
        log_info "Skipping brew dependencies (--no-brew mode)"
    else
        log_warn "Homebrew not found — skipping aerospace dependencies"
    fi

    # Remove old ~/.aerospace.toml to avoid AeroSpace ambiguity error
    local old_aerospace="$HOME/.aerospace.toml"
    if [[ -e "$old_aerospace" || -L "$old_aerospace" ]]; then
        backup_if_exists "$old_aerospace"
    fi
    make_executable "$DONBURI_DIR/aerospace/scripts" "*.sh"
    create_symlink "$SRC_AEROSPACE" "$DST_AEROSPACE"
}

setup_tmux() {
    echo -e "${CYAN}--- tmux ---${NC}"

    # Install TPM (Tmux Plugin Manager) if missing
    local tpm_dir="$HOME/.tmux/plugins/tpm"
    if [[ ! -d "$tpm_dir" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "Would install TPM (Tmux Plugin Manager)"
        else
            log_info "Installing TPM (Tmux Plugin Manager)..."
            git clone --depth=1 https://github.com/tmux-plugins/tpm "$tpm_dir"
        fi
    else
        log_info "TPM already installed"
    fi

    create_symlink "$SRC_TMUX" "$DST_TMUX"

    # Install TPM plugins
    if [[ -x "$tpm_dir/bin/install_plugins" ]] && [[ "$DRY_RUN" != true ]]; then
        log_info "Installing tmux plugins via TPM..."
        "$tpm_dir/bin/install_plugins"
    elif [[ "$DRY_RUN" == true ]]; then
        log_info "Would install tmux plugins via TPM"
    fi
}

setup_zsh() {
    echo -e "${CYAN}--- zsh ---${NC}"

    # Install Oh My Zsh if missing
    if [[ ! -d "$HOME/.oh-my-zsh" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "Would install Oh My Zsh"
        else
            log_info "Installing Oh My Zsh..."
            sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
        fi
    else
        log_info "Oh My Zsh already installed"
    fi

    # Install Powerlevel10k theme if missing
    local p10k_dir="${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k"
    if [[ ! -d "$p10k_dir" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "Would install Powerlevel10k theme"
        else
            log_info "Installing Powerlevel10k theme..."
            git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$p10k_dir"
        fi
    else
        log_info "Powerlevel10k already installed"
    fi

    # Install CLI dependencies via Homebrew
    if [[ "$NO_BREW" != true ]] && find_brew; then
        local zsh_deps=(fzf lsd gnu-sed gawk)
        for pkg in "${zsh_deps[@]}"; do
            if ! "$BREW_CMD" list --formula "$pkg" &>/dev/null; then
                if [[ "$DRY_RUN" == true ]]; then
                    log_info "Would install formula: $pkg"
                else
                    log_info "Installing formula: $pkg"
                    "$BREW_CMD" install "$pkg"
                fi
            else
                log_info "Already installed: $pkg"
            fi
        done
    elif [[ "$NO_BREW" == true ]]; then
        log_info "Skipping CLI dependencies (--no-brew mode)"
    else
        log_warn "Homebrew not found — skipping CLI dependencies (fzf, lsd, gnu-sed, gawk)"
    fi

    create_symlink "$SRC_ZSH" "$DST_ZSH"
    create_symlink "$SRC_ZSH_DONBURI" "$DST_ZSH_DONBURI"
}

setup_sketchybar() {
    echo -e "${CYAN}--- sketchybar ---${NC}"

    # Install JetBrains Mono Nerd Font (shared with ghostty)
    if [[ "$NO_BREW" != true ]] && find_brew; then
        if ! "$BREW_CMD" list --cask font-jetbrains-mono-nerd-font &>/dev/null; then
            if [[ "$DRY_RUN" == true ]]; then
                log_info "Would install cask: font-jetbrains-mono-nerd-font"
            else
                log_info "Installing cask: font-jetbrains-mono-nerd-font"
                "$BREW_CMD" install --cask font-jetbrains-mono-nerd-font
            fi
        else
            log_info "Already installed: font-jetbrains-mono-nerd-font"
        fi
    elif [[ "$NO_BREW" == true ]]; then
        log_info "Skipping font installation (--no-brew mode)"
    else
        log_warn "Homebrew not found — skipping font installation"
    fi

    make_executable "$DONBURI_DIR/sketchybar" "sketchybarrc"
    make_executable "$DONBURI_DIR/sketchybar/plugins" "*.sh"
    create_symlink "$SRC_SKETCHYBAR" "$DST_SKETCHYBAR"
}

setup_all() {
    setup_nvim
    setup_ghostty
    setup_aerospace
    setup_tmux
    setup_zsh
    setup_sketchybar
}

# ---------------------------------------------------------------------------
# Brew Commands
# ---------------------------------------------------------------------------

brew_check() {
    if [[ "$NO_BREW" == true ]]; then
        log_warn "Brew operations disabled (--no-brew mode)"
        return 1
    fi

    if ! find_brew; then
        log_error "Homebrew not found in any standard location"
        echo ""
        echo "Homebrew is required for package installation."
        echo ""
        echo "Options:"
        echo "1. Install Homebrew: Visit https://brew.sh"
        echo "2. If Homebrew is installed in a custom location:"
        echo "   export DONBURI_BREW_PATH=/path/to/brew"
        echo "3. If you're in a corporate environment:"
        echo "   Ask your admin to run: sudo donburi brew all"
        echo "4. Skip brew dependencies: donburi setup --no-brew"
        return 1
    fi

    log_info "Using Homebrew at: $BREW_CMD"

    # Check if running with sudo when it might be needed
    if is_sudo; then
        log_warn "Running with sudo privileges - packages will be installed system-wide"
    fi

    return 0
}

brew_list_category() {
    local category="$1"
    case "$category" in
        apps)
            echo -e "${BOLD}Apps (UI applications):${NC}"
            echo "  Formulas: ${BREW_APPS_FORMULA[*]}"
            echo "  Casks:    ${BREW_APPS_CASK[*]}"
            ;;
        cli)
            echo -e "${BOLD}CLI (command-line tools):${NC}"
            echo "  Formulas: ${BREW_CLI_FORMULA[*]}"
            ;;
        utils)
            echo -e "${BOLD}Utils (dev utilities & communication):${NC}"
            echo "  Formulas: ${BREW_UTILS_FORMULA[*]}"
            echo "  Casks:    ${BREW_UTILS_CASK[*]}"
            ;;
        docker)
            echo -e "${BOLD}Docker (container tools):${NC}"
            echo "  Formulas: ${BREW_DOCKER_FORMULA[*]}"
            ;;
        all)
            brew_list_category apps
            echo ""
            brew_list_category cli
            echo ""
            brew_list_category utils
            echo ""
            brew_list_category docker
            ;;
    esac
}

brew_install_apps() {
    echo -e "${CYAN}--- brew: apps ---${NC}"
    for pkg in "${BREW_APPS_FORMULA[@]}"; do
        brew_install "$pkg" formula
    done
    for pkg in "${BREW_APPS_CASK[@]}"; do
        brew_install "$pkg" cask
    done
}

brew_install_cli() {
    echo -e "${CYAN}--- brew: cli ---${NC}"
    for pkg in "${BREW_CLI_FORMULA[@]}"; do
        brew_install "$pkg" formula
    done
}

brew_install_utils() {
    echo -e "${CYAN}--- brew: utils ---${NC}"
    for pkg in "${BREW_UTILS_FORMULA[@]}"; do
        brew_install "$pkg" formula
    done
    for pkg in "${BREW_UTILS_CASK[@]}"; do
        brew_install "$pkg" cask
    done
}

brew_install_docker() {
    echo -e "${CYAN}--- brew: docker ---${NC}"
    for pkg in "${BREW_DOCKER_FORMULA[@]}"; do
        brew_install "$pkg" formula
    done
}

cmd_brew() {
    local category="${1:-apps}"

    if [[ "$LIST_ONLY" == true ]]; then
        brew_list_category "$category"
        return 0
    fi

    brew_check || return 1

    case "$category" in
        apps)   brew_install_apps ;;
        cli)    brew_install_cli ;;
        utils)  brew_install_utils ;;
        docker) brew_install_docker ;;
        all)
            brew_install_apps
            brew_install_cli
            brew_install_utils
            brew_install_docker
            ;;
        *)
            log_error "Unknown brew category: $category"
            echo "Available categories: apps, cli, utils, docker, all"
            return 1
            ;;
    esac
}

# ---------------------------------------------------------------------------
# Status Command
# ---------------------------------------------------------------------------

check_link() {
    local label="$1"
    local source="$2"
    local target="$3"

    printf "  %-12s " "$label"
    if is_correct_symlink "$target" "$source"; then
        echo -e "${GREEN}OK${NC}  $target -> $source"
    elif [[ -L "$target" ]]; then
        echo -e "${YELLOW}WRONG${NC}  $target -> $(readlink "$target")  (expected $source)"
    elif [[ -e "$target" ]]; then
        echo -e "${YELLOW}EXISTS${NC}  $target (not a symlink)"
    else
        echo -e "${RED}MISSING${NC}  $target"
    fi
}

cmd_status() {
    echo "Symlink status:"
    check_link "nvim"       "$SRC_NVIM"       "$DST_NVIM"
    check_link "ghostty"    "$SRC_GHOSTTY"    "$DST_GHOSTTY"
    check_link "aerospace"  "$SRC_AEROSPACE"  "$DST_AEROSPACE"
    check_link "tmux"       "$SRC_TMUX"       "$DST_TMUX"
    check_link "zsh"        "$SRC_ZSH"        "$DST_ZSH"
    check_link "zsh-donburi" "$SRC_ZSH_DONBURI" "$DST_ZSH_DONBURI"
    check_link "sketchybar" "$SRC_SKETCHYBAR" "$DST_SKETCHYBAR"
}

# ---------------------------------------------------------------------------
# Brew Check Command
# ---------------------------------------------------------------------------

cmd_brew_check() {
    echo -e "${CYAN}=== Homebrew Installation Check ===${NC}"
    echo ""

    # Check environment variable first
    if [[ -n "${DONBURI_BREW_PATH:-}" ]]; then
        echo "Custom path set: DONBURI_BREW_PATH=$DONBURI_BREW_PATH"
        if [[ -x "$DONBURI_BREW_PATH" ]]; then
            echo -e "${GREEN}✓${NC} Custom brew path is valid"
        else
            echo -e "${RED}✗${NC} Custom brew path is not executable"
        fi
        echo ""
    fi

    # Try to find brew
    if find_brew; then
        echo -e "${GREEN}✓${NC} Homebrew found at: $BREW_CMD"
        echo "  Prefix: $BREW_PREFIX"

        # Get brew version
        if BREW_VERSION=$("$BREW_CMD" --version 2>/dev/null | head -n1); then
            echo "  Version: $BREW_VERSION"
        fi

        # Check if running with sudo
        if is_sudo; then
            echo -e "${YELLOW}⚠${NC} Running with sudo privileges"
            echo "  Packages will be installed system-wide"
        else
            echo "  Running as: $(whoami)"
        fi

        echo ""
        echo "Brew package categories available:"
        echo "  • apps: UI applications (nvim, ghostty, aerospace, etc.)"
        echo "  • cli: Command-line tools (bat, fzf, ripgrep, etc.)"
        echo "  • utils: Development utilities (node, python, slack, etc.)"
        echo "  • docker: Container tools (colima, docker, docker-compose)"
        echo ""
        echo "Run 'donburi brew --list' to see all packages"

    else
        echo -e "${RED}✗${NC} Homebrew not found"
        echo ""
        echo "Checked locations:"
        for location in "${BREW_LOCATIONS[@]}"; do
            if [[ -e "$location" ]]; then
                echo "  • $location (exists but not executable)"
            else
                echo "  • $location (not found)"
            fi
        done
        echo ""
        echo -e "${BOLD}Installation Options:${NC}"
        echo ""
        echo "1. Install Homebrew (recommended):"
        echo "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
        echo ""
        echo "2. If Homebrew is installed elsewhere:"
        echo "   export DONBURI_BREW_PATH=/path/to/brew"
        echo "   donburi brew-check"
        echo ""
        echo "3. For corporate environments:"
        echo "   • Ask your IT admin to install Homebrew"
        echo "   • Then run: sudo donburi brew all"
        echo ""
        echo "4. Skip brew dependencies:"
        echo "   donburi setup --no-brew"
        echo ""
        return 1
    fi
}

# ---------------------------------------------------------------------------
# Permissions Command
# ---------------------------------------------------------------------------

check_accessibility_permission() {
    local app_name="$1"
    local bundle_id="$2"

    # Check if app has accessibility permission (macOS TCC database)
    # Note: Direct TCC database access requires Full Disk Access
    # We'll check if the app can perform accessibility actions instead
    if [[ "$DRY_RUN" == true ]]; then
        echo "Would check accessibility for $app_name"
        return 0
    fi

    # Try to detect if accessibility is granted by checking if process is running
    # and if we can query its windows (requires accessibility)
    if pgrep -x "$app_name" >/dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} $app_name is running"
        return 0
    else
        echo -e "${YELLOW}⚠${NC} $app_name is not running - cannot verify permissions"
        return 1
    fi
}

check_service_status() {
    local service="$1"

    if [[ "$DRY_RUN" == true ]]; then
        echo "Would check service status for $service"
        return 0
    fi

    if ! find_brew; then
        echo -e "${RED}✗${NC} Homebrew not found - cannot check service status"
        return 1
    fi

    # Check if service is running
    if "$BREW_CMD" services list 2>/dev/null | grep -q "^$service.*started"; then
        echo -e "${GREEN}✓${NC} $service service is running"
        return 0
    else
        echo -e "${YELLOW}⚠${NC} $service service is not running"
        echo "    Run: brew services start $service"
        return 1
    fi
}

cmd_permissions() {
    echo -e "${CYAN}=== Permission Status Check ===${NC}"
    echo ""

    echo -e "${BOLD}Aerospace (Window Manager)${NC}"
    check_accessibility_permission "AeroSpace" "com.nikitabobko.AeroSpace"
    echo "  Required: Accessibility permission"
    echo "  To grant: System Settings → Privacy & Security → Accessibility → Enable AeroSpace"
    echo ""

    echo -e "${BOLD}Sketchybar (Menu Bar)${NC}"
    check_service_status "sketchybar"
    echo "  Required: Running as a service"
    if ! find_brew; then
        echo "  To start: Install Homebrew first, then run: brew services start sketchybar"
    else
        echo "  To start: brew services start sketchybar"
    fi
    echo ""

    echo -e "${BOLD}Borders (Window Borders - Optional)${NC}"
    check_accessibility_permission "borders" "com.felixkratz.borders"
    echo "  Optional: Screen Recording permission for window borders"
    echo "  To grant: System Settings → Privacy & Security → Screen Recording → Enable Borders"
    echo ""

    echo -e "${BOLD}Ghostty (Terminal)${NC}"
    # Use ps instead of pgrep as pgrep has issues finding ghostty on macOS
    if ps aux | grep -q "[G]hostty.app"; then
        echo -e "${GREEN}✓${NC} Ghostty is running"
    else
        echo -e "${YELLOW}⚠${NC} Ghostty is not running"
        echo "  Note: Launch Ghostty once to trigger any permission dialogs"
    fi
    echo ""

    echo -e "${CYAN}=== Quick Actions ===${NC}"
    echo ""
    echo "Open System Preferences directly:"
    echo "  • Accessibility: open 'x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility'"
    echo "  • Screen Recording: open 'x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture'"
    echo ""

    if is_sudo; then
        echo -e "${YELLOW}Note: Running with sudo - some permission checks may not work correctly${NC}"
        echo "Permission checks should be run as the regular user, not with sudo."
    fi
}

# ---------------------------------------------------------------------------
# Update Command
# ---------------------------------------------------------------------------

cmd_update() {
    echo -e "${CYAN}--- update ---${NC}"

    if [[ ! -d "$DONBURI_DIR/.git" ]]; then
        log_error "Not a git repository: $DONBURI_DIR"
        return 1
    fi

    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would run: git pull"
        git -C "$DONBURI_DIR" fetch --dry-run
    else
        log_info "Pulling latest changes..."
        git -C "$DONBURI_DIR" pull
        log_info "Donburi updated successfully"
    fi
}

# ---------------------------------------------------------------------------
# Help Command
# ---------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Donburi - A unified macOS dotfiles configuration

Usage: donburi <command> [options]

Commands:
  setup [component]     Install configurations (default: all)
                        Components: nvim, ghostty, aerospace, tmux, zsh, sketchybar
  status                Show symlink status
  brew [category]       Install packages via Homebrew
                        Categories: apps (default), cli, utils, docker, all
  brew-check            Check Homebrew installation and configuration
  permissions           Check macOS permissions for apps
  update                Update donburi via git pull
  help                  Show this help message

Admin Commands (require sudo):
  admin-setup           Complete admin setup for enterprise
  admin-check           Verify admin setup is complete

Options:
  --version, -v         Show version
  --dry-run             Preview changes without applying
  --no-brew             Skip all Homebrew operations (setup only)
  --list                Show packages without installing (brew only)

Examples:
  donburi setup                 # Install all configurations
  donburi setup nvim            # Install only Neovim config
  donburi setup --dry-run       # Preview all setup changes
  donburi setup --no-brew       # Setup configs without brew dependencies
  donburi status                # Check symlink status
  donburi brew                  # Install apps (nvim, ghostty, etc.)
  donburi brew cli              # Install CLI tools (bat, fzf, etc.)
  donburi brew all              # Install all packages
  donburi brew --list           # Show all available packages
  donburi brew-check            # Check Homebrew installation
  donburi permissions           # Check app permissions
  donburi update                # Update donburi to latest version
  sudo donburi admin-setup      # Run complete admin setup (IT staff)
  donburi admin-check           # Verify admin setup is complete

For more information, see: https://github.com/jonatas/donburi
EOF
}

# ---------------------------------------------------------------------------
# Admin Commands for Enterprise Setup
# ---------------------------------------------------------------------------

cmd_admin_setup() {
    echo -e "${CYAN}=== Donburi Admin Setup ===${NC}"
    echo ""

    # Check if running with sudo
    if ! is_sudo; then
        echo -e "${RED}ERROR: This command requires sudo privileges${NC}"
        echo "Please run: sudo donburi admin-setup"
        exit 1
    fi

    echo "This command will help administrators set up donburi for enterprise users."
    echo "It will:"
    echo "  1. Install all required Homebrew packages"
    echo "  2. Start necessary services (sketchybar)"
    echo "  3. Guide you through granting system permissions"
    echo ""
    echo -e "${YELLOW}Press Enter to continue or Ctrl+C to cancel...${NC}"
    read -r

    # Step 1: Check Homebrew installation
    echo ""
    echo -e "${BOLD}Step 1: Checking Homebrew...${NC}"
    if ! find_brew; then
        echo -e "${RED}Homebrew is not installed!${NC}"
        echo "Please install Homebrew first:"
        echo '  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
        exit 1
    fi
    echo -e "${GREEN}✓ Homebrew found at: $BREW_CMD${NC}"

    # Step 2: Install all packages
    echo ""
    echo -e "${BOLD}Step 2: Installing required packages...${NC}"
    echo "This may take several minutes..."
    cmd_brew "all"

    # Step 3: Start sketchybar service
    echo ""
    echo -e "${BOLD}Step 3: Starting services...${NC}"
    echo "Starting sketchybar service..."
    if "$BREW_CMD" services start sketchybar 2>&1 | grep -q "Successfully started"; then
        echo -e "${GREEN}✓ Sketchybar service started${NC}"
    elif "$BREW_CMD" services list | grep -q "sketchybar.*started"; then
        echo -e "${GREEN}✓ Sketchybar service already running${NC}"
    else
        echo -e "${YELLOW}⚠ Could not verify sketchybar service status${NC}"
    fi

    # Step 4: Grant permissions
    echo ""
    echo -e "${BOLD}Step 4: System Permissions${NC}"
    echo ""
    echo "The following applications need system permissions."
    echo "I'll open the System Settings to the correct panes for you."
    echo ""

    echo -e "${CYAN}4a. Aerospace - Accessibility Permission${NC}"
    echo "   Aerospace needs this to manage windows"
    echo "   Action: Enable AeroSpace in the list"
    echo ""
    echo -e "${YELLOW}Opening Accessibility settings...${NC}"
    open "x-apple.systempreferences:com.apple.Accessibility-Settings.extension" 2>/dev/null || \
        open "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility" 2>/dev/null
    echo "Press Enter after granting permission..."
    read -r

    echo ""
    echo -e "${CYAN}4b. Borders - Screen Recording Permission (Optional)${NC}"
    echo "   JankyBorders adds colored borders to windows (visual enhancement only)"
    echo "   This is OPTIONAL - skip if you don't want window borders"
    echo "   Note: Despite the name, this does NOT record your screen"
    echo ""
    echo "Grant this permission? (y/N): "
    read -r grant_borders
    if [[ "$grant_borders" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Opening Screen Recording settings...${NC}"
        open "x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture" 2>/dev/null
        echo "Press Enter after granting permission (or skip)..."
        read -r
    else
        echo "Skipping Borders permission (optional component)"
    fi

    # Step 5: Verify setup
    echo ""
    echo -e "${BOLD}Step 5: Verifying setup...${NC}"
    echo ""
    cmd_admin_check

    echo ""
    echo -e "${GREEN}=== Admin setup complete! ===${NC}"
    echo ""
    echo "Next steps for users:"
    echo "  1. Install donburi: curl -fsSL https://raw.githubusercontent.com/jonatas/donburi/main/install.sh | bash"
    echo "  2. Setup configs: donburi setup --no-brew"
    echo ""
}

cmd_admin_check() {
    local all_good=true

    echo -e "${CYAN}=== Admin Setup Status ===${NC}"
    echo ""

    # Check Homebrew
    echo -e "${BOLD}Homebrew:${NC}"
    if find_brew; then
        echo -e "  ${GREEN}✓${NC} Installed at: $BREW_CMD"
    else
        echo -e "  ${RED}✗${NC} Not installed"
        all_good=false
    fi

    # Check key packages
    echo ""
    echo -e "${BOLD}Required packages:${NC}"
    local packages=("neovim" "ghostty" "aerospace" "sketchybar" "tmux" "jq" "borders")
    for pkg in "${packages[@]}"; do
        if "$BREW_CMD" list --formula 2>/dev/null | grep -q "^$pkg$" || \
           "$BREW_CMD" list --cask 2>/dev/null | grep -q "^$pkg$"; then
            echo -e "  ${GREEN}✓${NC} $pkg"
        else
            echo -e "  ${RED}✗${NC} $pkg not installed"
            all_good=false
        fi
    done

    # Check services
    echo ""
    echo -e "${BOLD}Services:${NC}"
    if "$BREW_CMD" services list 2>/dev/null | grep -q "sketchybar.*started"; then
        echo -e "  ${GREEN}✓${NC} Sketchybar service running"
    else
        echo -e "  ${YELLOW}⚠${NC} Sketchybar service not running"
        echo "      Run: brew services start sketchybar"
        all_good=false
    fi

    # Check permissions (basic check)
    echo ""
    echo -e "${BOLD}Permissions:${NC}"
    echo "  Note: Permission checks require the apps to be launched once"

    # Check if Aerospace has accessibility
    if check_accessibility_permission "AeroSpace" "com.nikitabobko.AeroSpace" 2>/dev/null; then
        echo -e "  ${GREEN}✓${NC} Aerospace has Accessibility permission"
    else
        echo -e "  ${YELLOW}⚠${NC} Aerospace needs Accessibility permission"
        echo "      Open: System Settings → Privacy & Security → Accessibility"
    fi

    # Check if Borders has screen recording (optional)
    if check_accessibility_permission "borders" "com.felixkratz.borders" 2>/dev/null; then
        echo -e "  ${GREEN}✓${NC} Borders has Screen Recording permission (optional)"
    else
        echo -e "  ${CYAN}ℹ${NC} Borders can use Screen Recording permission (optional)"
    fi

    echo ""
    if [[ "$all_good" == true ]]; then
        echo -e "${GREEN}✓ All admin tasks completed successfully!${NC}"
        return 0
    else
        echo -e "${YELLOW}⚠ Some admin tasks still need completion${NC}"
        return 1
    fi
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

# Parse global flags
while [[ "$1" == --* ]]; do
    case "$1" in
        --dry-run) DRY_RUN=true; shift ;;
        --list) LIST_ONLY=true; shift ;;
        --version|-v) cat "$DONBURI_DIR/VERSION"; exit 0 ;;
        --help|-h) cmd_help; exit 0 ;;
        *) log_error "Unknown option: $1"; cmd_help; exit 1 ;;
    esac
done

COMMAND="${1:-help}"
shift 2>/dev/null || true

# Header for commands that modify things
show_header() {
    echo "========================================"
    echo "Donburi"
    echo "========================================"
    echo "Source: $DONBURI_DIR"
    [[ "$DRY_RUN" == true ]] && echo -e "${YELLOW}Dry run mode${NC}"
    echo ""
}

# Footer for commands that modify things
show_footer() {
    echo ""
    echo "========================================"
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}Dry run complete. No changes were made.${NC}"
    else
        echo -e "${GREEN}Done!${NC}"
        if [[ -d "$BACKUP_DIR" ]]; then echo "Backups: $BACKUP_DIR"; fi
    fi
}

case "$COMMAND" in
    setup)
        # Parse setup-specific flags
        SETUP_COMPONENT=""
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --dry-run) DRY_RUN=true; shift ;;
                --no-brew) NO_BREW=true; shift ;;
                -*) log_error "Unknown option: $1"; exit 1 ;;
                *) SETUP_COMPONENT="$1"; shift ;;
            esac
        done
        show_header
        case "${SETUP_COMPONENT:-all}" in
            all)        setup_all ;;
            nvim)       setup_nvim ;;
            ghostty)    setup_ghostty ;;
            aerospace)  setup_aerospace ;;
            tmux)       setup_tmux ;;
            zsh)        setup_zsh ;;
            sketchybar) setup_sketchybar ;;
            *)
                log_error "Unknown component: $SETUP_COMPONENT"
                echo "Available components: nvim, ghostty, aerospace, tmux, zsh, sketchybar, all"
                exit 1
                ;;
        esac
        show_footer
        ;;
    status)
        cmd_status
        ;;
    brew)
        # Parse brew-specific flags
        BREW_ARG=""
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --list) LIST_ONLY=true; shift ;;
                --dry-run) DRY_RUN=true; shift ;;
                -*) log_error "Unknown option: $1"; exit 1 ;;
                *) BREW_ARG="$1"; shift ;;
            esac
        done
        if [[ "$LIST_ONLY" != true ]]; then
            show_header
        fi
        cmd_brew "${BREW_ARG:-apps}"
        if [[ "$LIST_ONLY" != true ]]; then
            show_footer
        fi
        ;;
    brew-check)
        cmd_brew_check
        ;;
    permissions)
        # Parse permissions-specific flags
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --dry-run) DRY_RUN=true; shift ;;
                -*) log_error "Unknown option: $1"; exit 1 ;;
                *) log_error "Unknown argument: $1"; exit 1 ;;
            esac
        done
        cmd_permissions
        ;;
    update)
        # Parse update-specific flags
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --dry-run) DRY_RUN=true; shift ;;
                -*) log_error "Unknown option: $1"; exit 1 ;;
                *) log_error "Unknown argument: $1"; exit 1 ;;
            esac
        done
        show_header
        cmd_update
        show_footer
        ;;
    admin-setup)
        # No argument parsing needed, handled in the function
        cmd_admin_setup
        ;;
    admin-check)
        # No argument parsing needed
        cmd_admin_check
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        log_error "Unknown command: $COMMAND"
        cmd_help
        exit 1
        ;;
esac
