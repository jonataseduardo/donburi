#!/opt/homebrew/bin/bash
# Ghostty Keybindings Helper
# Display Ghostty terminal macOS keybindings from live config in a formatted table with Kanagawa colors

set -euo pipefail

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Source the shared display library
source "$SCRIPT_DIR/lib/display.sh"

# Live config source (source of truth)
LIVE_CONFIG_FILE="$SCRIPT_DIR/../ghostty/config"
# Fallback reference file
REF_CONFIG_FILE="$SCRIPT_DIR/config/ghostty.ref"
# User override
USER_CONFIG_FILE="$HOME/.config/keybinds/ghostty.ref"

# Show usage
show_usage() {
    cat <<EOF
Usage: $(basename "$0") [options]

Display Ghostty terminal macOS keybindings in a formatted table with pager support.

The keybindings are read from the live Ghostty configuration.

Options:
  --no-pager  Output directly to terminal without pager
  --edit      Open Ghostty config file in \$EDITOR
  -h, --help  Show this help message

Examples:
  $(basename "$0")              # Show all keybindings in pager
  $(basename "$0") --no-pager   # Show without pager
  $(basename "$0") --edit       # Edit Ghostty configuration

Pager commands:
  /pattern    Search forward for pattern
  ?pattern    Search backward for pattern
  n           Next search match
  N           Previous search match
  q           Quit pager
  h           Show pager help

Config sources:
  Live config: $LIVE_CONFIG_FILE (source of truth)
  Reference:   $REF_CONFIG_FILE (fallback if live unavailable)
EOF
}

# Parse ghostty config file and display keybindings
display_keybindings() {
    # Determine which source to use
    local config_source
    if [[ -f "$LIVE_CONFIG_FILE" ]]; then
        config_source="$LIVE_CONFIG_FILE"
    else
        config_source="$REF_CONFIG_FILE"
    fi

    # Check if user override exists
    if [[ -f "$USER_CONFIG_FILE" ]]; then
        config_source="$USER_CONFIG_FILE"
    fi

    if [[ ! -f "$config_source" ]]; then
        echo "Error: No Ghostty config found"
        echo "Checked: $LIVE_CONFIG_FILE"
        echo "Fallback: $REF_CONFIG_FILE"
        return 1
    fi

    draw_header "Ghostty Keybindings"

    # Declare associative arrays for categories
    declare -A category_keys
    declare -A category_cmds

    # Parse keybindings from config
    # Format: keybind = key=action
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ -z "$line" ]] && continue

        # Extract keybind lines
        if [[ "$line" =~ keybind[[:space:]]*=[[:space:]]*(.*)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local cmd="${BASH_REMATCH[2]}"

            # Trim whitespace
            key="${key#"${key%%[![:space:]]*}"}"
            key="${key%"${key##*[![:space:]]}"}"
            cmd="${cmd#"${cmd%%[![:space:]]*}"}"
            cmd="${cmd%"${cmd##*[![:space:]]}"}"

            # Categorize the keybinding
            local category
            case "$cmd" in
                new_tab|close_surface|new_window|quit|toggle_fullscreen) category="Window/Tab Management" ;;
                goto_tab:*|previous_tab|next_tab) category="Tab Navigation" ;;
                copy_to_clipboard|paste_from_clipboard) category="Copy/Paste" ;;
                reload_config) category="Configuration" ;;
                text:*) category="Text Input" ;;
                *) category="Other" ;;
            esac

            # Append to category arrays
            if [[ -n "${category_keys[$category]:-}" ]]; then
                category_keys[$category]+=$'\n'"$key"
                category_cmds[$category]+=$'\n'"$cmd"
            else
                category_keys[$category]="$key"
                category_cmds[$category]="$cmd"
            fi
        fi
    done < "$config_source"

    # Get unique categories in order of appearance
    local -a categories=()
    declare -A seen_categories

    while IFS= read -r line; do
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ -z "$line" ]] && continue

        if [[ "$line" =~ keybind[[:space:]]*=[[:space:]]*(.*)=(.*)$ ]]; then
            local cmd="${BASH_REMATCH[2]}"
            cmd="${cmd#"${cmd%%[![:space:]]*}"}"
            cmd="${cmd%"${cmd##*[![:space:]]}"}"

            local category
            case "$cmd" in
                new_tab|close_surface|new_window|quit|toggle_fullscreen) category="Window/Tab Management" ;;
                goto_tab:*|previous_tab|next_tab) category="Tab Navigation" ;;
                copy_to_clipboard|paste_from_clipboard) category="Copy/Paste" ;;
                reload_config) category="Configuration" ;;
                text:*) category="Text Input" ;;
                *) category="Other" ;;
            esac

            if [[ -z "${seen_categories[$category]:-}" ]]; then
                categories+=("$category")
                seen_categories[$category]=1
            fi
        fi
    done < "$config_source"

    # Display by category in order
    local first_category=true
    for category in "${categories[@]}"; do
        if [[ -n "${category_keys[$category]:-}" ]]; then
            if [[ "$first_category" != true ]]; then
                draw_line "$BOX_ML" "$BOX_X" "$BOX_MR"
            fi
            first_category=false

            # Use a color for category
            local color="$CYAN"
            case "$category" in
                "Window/Tab Management") color="$BLUE" ;;
                "Tab Navigation") color="$GREEN" ;;
                "Copy/Paste") color="$MAGENTA" ;;
                "Configuration") color="$YELLOW" ;;
                "Text Input") color="$ORANGE" ;;
                *) color="$WHITE" ;;
            esac

            draw_category "$category" "$color"

            # Display each binding in this category
            while IFS= read -r key && IFS= read -r cmd <&3; do
                draw_row "$key" "$cmd"
            done < <(echo "${category_keys[$category]}") 3< <(echo "${category_cmds[$category]}")
        fi
    done

    draw_footer
}

# Main
main() {
    local use_pager=true
    local edit_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            --no-pager)
                use_pager=false
                shift
                ;;
            --edit)
                edit_mode=true
                shift
                ;;
            *)
                cat >&2 <<EOF
Unknown option: $1
EOF
                show_usage >&2
                exit 1
                ;;
        esac
    done

    # Handle edit mode
    if [[ "$edit_mode" == true ]]; then
        if [[ ! -f "$LIVE_CONFIG_FILE" ]]; then
            echo "Error: Ghostty config not found at $LIVE_CONFIG_FILE"
            exit 1
        fi
        ${EDITOR:-nano} "$LIVE_CONFIG_FILE"
        exit 0
    fi

    # Generate output with or without pager
    if [[ "$use_pager" == true ]]; then
        pager_cmd=$(setup_pager)
        if [[ -n "$pager_cmd" ]]; then
            # Use pager if available
            display_keybindings | eval "$pager_cmd"
        else
            # Fallback to direct output if no pager
            display_keybindings
        fi
    else
        # Direct output without pager
        display_keybindings
    fi
}

main "$@"
